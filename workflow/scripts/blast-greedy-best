#!/usr/bin/env perl
# Created: 09 Feb 2024
# Author: Thomas Hackl, thackl@lim4.de
use warnings;
use strict;
use Getopt::Long  qw(:config no_ignore_case bundling);
use Data::Dumper;

GetOptions (
    "out|o=s" => sub { '-' ne $_[1] and open(STDOUT, '>', $_[1]) || die $! },
    "overlap|p=f" => \(my $opt_overlap = .5),
    "keep-max|k=i" => \(my $opt_keep_max = 1),
    "help|h!" => \(my $help),
    "debug|D!" => \(my $debug),
) or die("Error in command line arguments\n");

if ($help){
    print "Usage: blast-greedy-best < in > out\n".
        "Keep only the highest scoring hits along the subject sequence.\n".
        "Remove all hits that overlap at least <k> higher-scoring hits\n".
        "by the specified proportion <p>.\n";
    printf " %-19s  %s\n", "-o/--out", "write to this file [STDOUT]";
    printf " %-19s  %s\n", "-p/--overlap", "Minimum overlap as fraction of shorter sequence [$opt_overlap]";
    printf " %-19s  %s\n", "-k/--keep-max", "Maximum highest-scoring hits per overlapping group [$opt_keep_max]";
    printf " %-19s  %s\n", "-h/--help", "show this help";
    printf " %-19s  %s\n", "-D/--debug", "show debug messages";
    exit 0;
}

# relevant blast columns
use constant {
    sseqid => 0,
    sstart => 6,
    ssend => 7,
    bitscore => 11
};

my @r = split("\t", scalar <>);
my @p = [@r];
my $k = $opt_keep_max-1;

while (<>) {
    @r = split("\t", $_);
    my $o = overlap(@{$p[0]}[sseqid, sstart, ssend], @r[sseqid, sstart, ssend]);
    if ($o < $opt_overlap){
        # print and reset group
        print join("\t", @$_) for @p;
        @p = [@r];
    }else{
        # move up throw previous hits and see if bitscore is higher
        for(my $i=@p; $i; $i--){
            if($r[bitscore] <= $p[$i-1][bitscore] && $i <= $k){
                splice @p, $i, 0, [@r];
                last;
            }
        }
        @p = @p[0..$k] if $#p > $k;
    }
}
print join("\t", @$_) for @p;



sub overlap{
    my ($xi, $xs, $xe, $yi, $ys, $ye) = @_;
    # same id
    $xi eq $yi || return 0;
    # same strand
    $xs < $xe == $ys < $ye || return 0;
    # abs overlap
    ($xs, $xe) = sort ($xs, $xe);
    ($ys, $ye) = sort ($ys, $ye);
    $xs <= $ye && $ys <= $xe || return 0;
    my $o = (sort ($xe, $ye))[0] - (sort ($xs, $ys))[1];
    $o > 0 || return 0;
    # % of shorter seq
    my ($xyshorter) =  sort ($xe-$xs, $ye-$ys);
    return $o / $xyshorter;
}
